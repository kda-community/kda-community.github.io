"use strict";(self.webpackChunkkadena_docs=self.webpackChunkkadena_docs||[]).push([[6727],{99376:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>p,frontMatter:()=>c,metadata:()=>o,toc:()=>r});const o=JSON.parse('{"id":"pact-5/operators/not-q","title":"not?","description":"Use not? to apply a logical NOT operation to the results of applying a specified value to an application function.","source":"@site/docs/pact-5/operators/not-q.md","sourceDirName":"pact-5/operators","slug":"/pact-5/operators/not-q","permalink":"/docs/pact-5/operators/not-q","draft":false,"unlisted":false,"editUrl":"https://github.com/kda-community/kadena-docs-new/blob/master/docs/pact-5/operators/not-q.md","tags":[],"version":"current","frontMatter":{},"sidebar":"default","previous":{"title":"not-equal (!=)","permalink":"/docs/pact-5/operators/neq"},"next":{"title":"not","permalink":"/docs/pact-5/operators/not"}}');var a=t(74848),s=t(28453);const c={},i="not?",l={},r=[{value:"Basic syntax",id:"basic-syntax",level:2},{value:"Arguments",id:"arguments",level:2},{value:"Return value",id:"return-value",level:2},{value:"Examples",id:"examples",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"not",children:"not?"})}),"\n",(0,a.jsxs)(n.p,{children:["Use ",(0,a.jsx)(n.code,{children:"not?"})," to apply a logical NOT operation to the results of applying a specified ",(0,a.jsx)(n.code,{children:"value"})," to an application function."]}),"\n",(0,a.jsxs)(n.p,{children:["You can use any data type for the ",(0,a.jsx)(n.code,{children:"value"})," argument as long as the ",(0,a.jsx)(n.code,{children:"app"})," function takes that same data type and returns the resulting boolean value for the logical NOT operation performed by the ",(0,a.jsx)(n.code,{children:"not?"})," function."]}),"\n",(0,a.jsxs)(n.p,{children:["By convention, the data type ",(0,a.jsx)(n.code,{children:"<a>"})," is used if an argument represents a type-bound parameter like the ",(0,a.jsx)(n.code,{children:"value"})," argument in this function:"]}),"\n",(0,a.jsx)(n.h2,{id:"basic-syntax",children:"Basic syntax"}),"\n",(0,a.jsxs)(n.p,{children:["To apply a logical NOT operation to the results of applying a specified ",(0,a.jsx)(n.code,{children:"value"})," to an application function ",(0,a.jsx)(n.code,{children:"app"}),", use the following syntax:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-pact",children:"(not? app value)\n"})}),"\n",(0,a.jsx)(n.h2,{id:"arguments",children:"Arguments"}),"\n",(0,a.jsxs)(n.p,{children:["Use the following arguments to specify the application function and the value to be applied using the ",(0,a.jsx)(n.code,{children:"not?"})," Pact function."]}),"\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"Argument"}),(0,a.jsx)(n.th,{children:"Type"}),(0,a.jsx)(n.th,{children:"Description"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"app"})}),(0,a.jsxs)(n.td,{children:["function x: ",(0,a.jsx)(n.code,{children:"<a> -> bool"})]}),(0,a.jsxs)(n.td,{children:["Specifies the application function to apply the specified ",(0,a.jsx)(n.code,{children:"value"})," to. The result of applying the specified value returns a boolean value."]})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"value"})}),(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"<a>"})}),(0,a.jsx)(n.td,{children:"Specifies the value to be applied to the application function."})]})]})]}),"\n",(0,a.jsx)(n.h2,{id:"return-value",children:"Return value"}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"not?"})," function returns a boolean value representing the logical negation of the result of applying the value to the application function."]}),"\n",(0,a.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,a.jsxs)(n.p,{children:["The following example demonstrates how to use the ",(0,a.jsx)(n.code,{children:"not?"})," function in the Pact REPL:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-pact",children:"pact> (not? (> 20) 15)\nfalse\n"})}),"\n",(0,a.jsxs)(n.p,{children:["In this example, the application function is ",(0,a.jsx)(n.code,{children:"(> 20)"})," and the value is ",(0,a.jsx)(n.code,{children:"15"}),". Because the expression ",(0,a.jsx)(n.code,{children:"20 > 15"})," evaluates to ",(0,a.jsx)(n.code,{children:"true"}),", and ",(0,a.jsx)(n.code,{children:"not?"})," negates this value, the ",(0,a.jsx)(n.code,{children:"not?"})," function returns ",(0,a.jsx)(n.code,{children:"false"}),"."]})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>c,x:()=>i});var o=t(96540);const a={},s=o.createContext(a);function c(e){const n=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:c(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);