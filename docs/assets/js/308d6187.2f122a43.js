"use strict";(self.webpackChunkkadena_docs=self.webpackChunkkadena_docs||[]).push([[2818],{31038:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>u,frontMatter:()=>r,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"smart-contracts/modules","title":"Modules and interfaces","description":"Modules define the business logic and essential functions for blockchain applications and provide the basic foundation for all Pact smart contracts.","source":"@site/docs/smart-contracts/modules.md","sourceDirName":"smart-contracts","slug":"/smart-contracts/modules","permalink":"/docs/smart-contracts/modules","draft":false,"unlisted":false,"editUrl":"https://github.com/kda-community/kadena-docs-new/blob/master/docs/smart-contracts/modules.md","tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"title":"Modules and interfaces","description":"Modules define the business logic and essential functions for blockchain applications and provide the basic foundation for all Pact smart contracts.","id":"modules","sidebar_position":7},"sidebar":"default","previous":{"title":"Functions, variables, and types","permalink":"/docs/smart-contracts/functions-variables"},"next":{"title":"Capabilities","permalink":"/docs/smart-contracts/capabilities"}}');var o=t(74848),i=t(28453);const r={title:"Modules and interfaces",description:"Modules define the business logic and essential functions for blockchain applications and provide the basic foundation for all Pact smart contracts.",id:"modules",sidebar_position:7},s="Modules and interfaces",c={},l=[{value:"Module declaration",id:"module-declaration",level:2},{value:"Modules and smart contracts",id:"modules-and-smart-contracts",level:2},{value:"Module keyword and owner",id:"module-keyword-and-owner",level:2},{value:"Module governance",id:"module-governance",level:2},{value:"Invoking governance",id:"invoking-governance",level:3},{value:"Module administrator scope",id:"module-administrator-scope",level:3},{value:"Stakeholder upgrade vote",id:"stakeholder-upgrade-vote",level:3},{value:"Module properties and components",id:"module-properties-and-components",level:2},{value:"Module versioning and dependencies",id:"module-versioning-and-dependencies",level:3},{value:"Module table creation",id:"module-table-creation",level:3},{value:"Interfaces",id:"interfaces",level:2},{value:"Interface properties and components",id:"interface-properties-and-components",level:3},{value:"Implements and use keywords",id:"implements-and-use-keywords",level:2},{value:"Module references",id:"module-references",level:2},{value:"Polymorphism",id:"polymorphism",level:3},{value:"Reference value binding",id:"reference-value-binding",level:3},{value:"Referencing untrusted code",id:"referencing-untrusted-code",level:3},{value:"Coding with module references",id:"coding-with-module-references",level:3},{value:"Securing module reference calls",id:"securing-module-reference-calls",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"modules-and-interfaces",children:"Modules and interfaces"})}),"\n",(0,o.jsxs)(n.p,{children:["The fundamental building blocks for all Pact smart contracts are defined in Pact ",(0,o.jsx)(n.strong,{children:"modules"})," and ",(0,o.jsx)(n.strong,{children:"interfaces"}),".\nAs Pact code, modules and interfaces have some similarities, but they are used differently have different usage rules."]}),"\n",(0,o.jsx)(n.p,{children:"A a high level:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Module are typically self-contained logical units with all of the code necessary to create an application or a service\u2014including schemas and tables\u2014and can be upgraded after they are deployed."}),"\n",(0,o.jsx)(n.li,{children:"Interfaces enable modules to interact by defining constant values and typed function signatures for common operations that can't be changed except by defining a new interface."}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"module-declaration",children:"Module declaration"}),"\n",(0,o.jsxs)(n.p,{children:["All of the functions and data definitions required to complete business operations are defined within the context of a module.\nFor simple contracts, all of the business logic might be defined in a single module.\nYou can also use modules as composable units that interoperate if iit makes complex logic easier to navigate.\nWhether you are building a contract as a single, self-contained Pact module or using multiple modules, ",(0,o.jsx)(n.strong,{children:"module declarations"})," typically include the following components:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Capability definitions"}),"\n",(0,o.jsx)(n.li,{children:"Schema definitions"}),"\n",(0,o.jsx)(n.li,{children:"Table definitions"}),"\n",(0,o.jsx)(n.li,{children:"Function definitions"}),"\n",(0,o.jsx)(n.li,{children:"Multi-step defpact definitions"}),"\n",(0,o.jsx)(n.li,{children:"Constant value definitions"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"There are also components that are required by smart contracts that aren't part of the module declaration, but are defined outside of the module code.\nFor example, the code related to the following components is considered to be outside of and separate from the module declaration:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Namespace definition"}),"\n",(0,o.jsx)(n.li,{children:"Keyset definitions"}),"\n",(0,o.jsx)(n.li,{children:"Table creation"}),"\n",(0,o.jsx)(n.li,{children:"Function calls"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"In addition to the module declaration and the components that aren't included in the module declaration, modules often require information passed in as message data, separate from the Pact code, but part of the transaction payload.\nFor example, a module might require keys or environment data that's referenced in Pact code, but provided as part of the JSON object to be executed as a transaction."}),"\n",(0,o.jsx)(n.h2,{id:"modules-and-smart-contracts",children:"Modules and smart contracts"}),"\n",(0,o.jsxs)(n.p,{children:["When you start working with Pact, you typically create single modules that contain the full functionality of your smart contract, much like most of the examples in the ",(0,o.jsx)(n.a,{href:"/coding-projects/coding-projects",children:"coding projects"}),".\nUsing a single module to define a contract keeps your codebase simple and straightforward because there's only one file to keep track of.\nHowever, as you begin writing more complex or sophisticated programs, you might find it more convenient to split the smart contract logic into multiple modules that work together to compose the complete application.\nIn a typical smart contract\u2014the full application\u2014each individual module can provide a focused set of functionality with clear organizational logic."]}),"\n",(0,o.jsxs)(n.p,{children:["Because a smart contract can be defined using one module or many modules and interfaces, the logic in individual Pact file\u2014with the ",(0,o.jsx)(n.code,{children:".pact"})," file extension\u2014is always referred to as a module or an interface."]}),"\n",(0,o.jsx)(n.h2,{id:"module-keyword-and-owner",children:"Module keyword and owner"}),"\n",(0,o.jsxs)(n.p,{children:["You can start a module declaration by typing the ",(0,o.jsx)(n.a,{href:"/reference/syntax#module",children:(0,o.jsx)(n.code,{children:"module"})})," keyword, followed by the module name and the keyset or governance capability that owns the module.\nThe following example illustrates a module named ",(0,o.jsx)(n.strong,{children:"example"})," that is governed by the ",(0,o.jsx)(n.strong,{children:"admin-keyset"})," referenced in the first line of the module declaration:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-pact",children:';; Define and read keysets\n\n(module example "admin-keyset"\n    ;; module code goes here\n\n    ;; function calls\n)\n'})}),"\n",(0,o.jsxs)(n.p,{children:["The entire ",(0,o.jsx)(n.strong,{children:"example"})," module consists of the code within the opening and closing parentheses.\nTop-level code, like ",(0,o.jsx)(n.code,{children:"namespace"})," definitions and ",(0,o.jsx)(n.code,{children:"keyset"})," definitions, are outside of these parentheses.\nFor example, you enter a namespace and define a keyset for a module before starting the module declaration like this:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-pact",children:';; Enter a namespace\n(namespace "free")\n\n;; Define and read a keyset\n(define-keyset "free.admin-keyset" (read-keyset "admin-keyset"))\n\n(module example "admin-keyset"\n    ;; module code goes here\n\n    ;; function calls\n)\n'})}),"\n",(0,o.jsx)(n.h2,{id:"module-governance",children:"Module governance"}),"\n",(0,o.jsxs)(n.p,{children:["With keyset governance like the previous example, the ",(0,o.jsx)(n.code,{children:"admin-keyset"})," is defined outside of the module and checked and enforced at the module level.\nAny attempt to upgrade the module, write to module tables, or access table functions directly requires the ",(0,o.jsx)(n.code,{children:"admin-keyset"})," to sign the transaction."]}),"\n",(0,o.jsxs)(n.p,{children:["As an alternative to strict keyset enforcement, you can specify a ",(0,o.jsx)(n.em,{children:"governance capability"})," in the module declaration to support a more generalized form of module governance.\nBy using a governance capability that references a ",(0,o.jsx)(n.code,{children:"defcap"})," declaration in the module body, you can define more flexible models for enforcing access to Pact modules, tables, and functions."]}),"\n",(0,o.jsxs)(n.p,{children:["For example, you can implement the same governance for the ",(0,o.jsx)(n.strong,{children:"example"})," module using a governance capability named ",(0,o.jsx)(n.strong,{children:"GOVERNANCE"})," like this:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-pact",children:'(module example GOVERNANCE\n  ...\n  (defcap GOVERNANCE ()\n    (enforce-guard "admin-keyset"))\n  ...\n)\n'})}),"\n",(0,o.jsx)(n.p,{children:"Note that the capability name has no significance, except to indicate the purpose of the capability.\nIts placement at the beginning of the module declaration is what identifies this capability as a module governance capability."}),"\n",(0,o.jsx)(n.p,{children:"It's worth noting that, when you initially deploy a module, the module governance capability is not invoked.\nThis behavior is different than when you use a keyset.\nWith a keyset, the keyset must always be defined and evaluated to ensure that the keyset exists before a module can be deployed.\nThe module governance capability is enforces after a module is deployed, when it's accessed or upgraded."}),"\n",(0,o.jsx)(n.h3,{id:"invoking-governance",children:"Invoking governance"}),"\n",(0,o.jsxs)(n.p,{children:["Because the module governance capability is defined using the ",(0,o.jsx)(n.code,{children:"defcap"})," keyword, its elevated administrative function cannot be called directly.\nThe ",(0,o.jsx)(n.strong,{children:"module administrator"})," elevated permissions are only automatically invoked in the following situations:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"When a module upgrade is attempted."}),"\n",(0,o.jsx)(n.li,{children:"When module tables are directly accessed from outside of the module code."}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["Transactions that attempt to upgrade a module or access module tables can only be executed by the module owner specified by the ",(0,o.jsx)(n.strong,{children:"module administrator capability"}),"\u2014in this example, the ",(0,o.jsx)(n.code,{children:"GOVERNANCE"})," capability.\nIf the conditions specified for the ",(0,o.jsx)(n.code,{children:"GOVERNANCE"})," capability are met, full administrative rights are granted."]}),"\n",(0,o.jsx)(n.h3,{id:"module-administrator-scope",children:"Module administrator scope"}),"\n",(0,o.jsxs)(n.p,{children:["The module administrator capability, once automatically invoked, stays in scope for the rest of the calling transaction.\nThis is unlike other capabilities that can only be acquired in a fixed scope specified by the body of a ",(0,o.jsx)(n.code,{children:"with-capability"})," function call.\nThe reason for this difference in behavior is to ensure that a governance capability doesn't rely on transient information that can change during a single transaction.\nThis is important, for example, in the case of module upgrades.\nA module upgrade might change the governance capability itself.\nIf the module administrator capability didn't remain in scope through the completion of the transaction, the upgrade might fail because the administrative capability is required to migrate table data as part of the upgrade process."]}),"\n",(0,o.jsx)(n.h3,{id:"stakeholder-upgrade-vote",children:"Stakeholder upgrade vote"}),"\n",(0,o.jsx)(n.p,{children:"The following example demonstrates how to upgrade a module based on a stakeholder vote.\nThe upgrade is designed as a Pact transaction, and its hash and code are distributed to stakeholders, who vote for or against the upgrade.\nAfter the upgrade transaction is distributed, the vote is tallied in the governance capability, and if a simple majority is found, the code is upgraded."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-pact",children:'(module govtest count-votes\n  "Demonstrate programmable governance showing votes \\\n \\ for upgrade transaction hashes"\n  (defschema vote\n    vote-hash:string)\n\n  (deftable votes:{vote})\n\n  (defun vote-for-hash (user hsh)\n    "Register a vote for a particular transaction hash"\n    (write votes user { "vote-hash": hsh })\n  )\n\n  (defcap count-votes ()\n    "Governance capability to tally votes for the upgrade hash".\n    (let* ((h (tx-hash))\n           (tally (fold (do-count h)\n                        { "for": 0, "against": 0 }\n                        (keys votes)))\n          )\n      (enforce (> (at \'for tally) (at \'against tally))\n               (format "vote result: {}, {}" [h tally])))\n  )\n\n  (defun do-count (hsh tally u)\n    "Add to TALLY if U has voted for HSH"\n    (bind tally { "for" := f, "against" := a }\n      (with-read votes u { \'vote-hash := v }\n        (if (= v hsh)\n            { "for": (+ 1 f), "against": a }\n          { "for": f, "against": (+ 1 a) })))\n  )\n)\n'})}),"\n",(0,o.jsx)(n.h2,{id:"module-properties-and-components",children:"Module properties and components"}),"\n",(0,o.jsxs)(n.p,{children:["As you've seen, module declarations start with the ",(0,o.jsx)(n.code,{children:"module"})," keyword and a name.\nModule names must be unique within a namespace.\nYou can define custom namespaces for local development.\nHowever, you must deploy modules to a registered namespace in the Kadena test or production networks."]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.a,{href:"/reference/syntax#module",children:"Module declarations"})," use the following keywords to define module components:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.a,{href:"/reference/syntax#defun",children:"defun"})," to define module functions."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.a,{href:"/reference/syntax#defschema",children:"defschema"})," to define schemas for module tables."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.a,{href:"/reference/syntax#deftable",children:"deftable"})," to define the tables to create for a module."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.a,{href:"/reference/syntax#defpact",children:"defpact"})," to define multi-step transactions in the module."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.a,{href:"/reference/syntax#defconst",children:"defconst"})," to define constant value variables in the module."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.a,{href:"/reference/syntax#defcap",children:"defcap"})," to define capabilities in the module."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.a,{href:"/reference/syntax#use",children:"use"})," to import functions from other modules into the module."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.a,{href:"/reference/syntax#implements",children:"implements"})," to implement functions from interfaces exposed in other modules into the module."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Modules can also include different types of metadata, such as documentation strings or information for emitted events."}),"\n",(0,o.jsx)(n.p,{children:"When a module is declared, all references to native functions, interfaces, or definitions from other modules are resolved.\nResolution failure results in transaction rollback."}),"\n",(0,o.jsx)(n.h3,{id:"module-versioning-and-dependencies",children:"Module versioning and dependencies"}),"\n",(0,o.jsxs)(n.p,{children:["Module versioning is not supported, except by including a version identifier in the module name, for example, ",(0,o.jsx)(n.code,{children:"accounts-v1"})," or ",(0,o.jsx)(n.code,{children:"marmalade-v2"}),".\nHowever, you can use ",(0,o.jsx)(n.em,{children:"module hashes"})," to import a specific version of a module with the ",(0,o.jsx)(n.a,{href:"/reference/syntax#use",children:(0,o.jsx)(n.code,{children:"use"})})," keyword.\nBy specifying a module hash when you import the module, you can link your code to a particular release of a module that's identified by the hash."]}),"\n",(0,o.jsx)(n.p,{children:"By combining module imports with module hashes, you can ensure that updated module code will fail to import if a dependent module has subsequently changed on the chain."}),"\n",(0,o.jsx)(n.h3,{id:"module-table-creation",children:"Module table creation"}),"\n",(0,o.jsxs)(n.p,{children:["Tables are created at the same time as modules and include the module name as a prefix to the table name.\nWith this naming convention, the module acts as a guard to protect access to tables using ",(0,o.jsx)(n.a,{href:"/pact-5/database",children:"database functions"})," that are controlled by the module owner.\nYou can create any number of tables in a module."]}),"\n",(0,o.jsxs)(n.p,{children:["It\u2019s important to note that you define table schemas, the tables that use the schemas, and the functions that insert, read, and modify database records inside of module code, but you create tables outside of module code.\nThat is, tables are ",(0,o.jsx)(n.em,{children:"defined"})," in modules, but they are ",(0,o.jsx)(n.em,{children:"created"})," after the module declaration.\nThis separation allows module code to be potentially updated without recreating the table."]}),"\n",(0,o.jsx)(n.h2,{id:"interfaces",children:"Interfaces"}),"\n",(0,o.jsx)(n.p,{children:"In Pact, interfaces represent an abstract API that modules can implement to make use of the constants and typed function signatures that an interface defines."}),"\n",(0,o.jsxs)(n.p,{children:["To make use of the components defined in an interface, module declarations can include one or more ",(0,o.jsx)(n.a,{href:"/reference/syntax#implements",children:(0,o.jsx)(n.code,{children:"implements"})})," statements to specify the interface from which the module wants to implement features.\nA single module can implement multiple interfaces.\nHowever, if you implement interfaces with conflicting function names, you must resolve the conflict in your code or by redefining the interfaces to remove the conflict."]}),"\n",(0,o.jsx)(n.h3,{id:"interface-properties-and-components",children:"Interface properties and components"}),"\n",(0,o.jsxs)(n.p,{children:["You can declare an interface using the ",(0,o.jsx)(n.code,{children:"interface"})," keyword followed by the name for the interface.\nInterface names must be unique within a namespace.\nInterfaces can't be upgraded and aren't governed by keysets or a governance capability."]}),"\n",(0,o.jsxs)(n.p,{children:["Interfaces can import definitions from other modules with ",(0,o.jsx)(n.a,{href:"/reference/syntax#use",children:(0,o.jsx)(n.code,{children:"use"})})," statements to construct new constant definitions, or make use of types or functions defined in the imported module."]}),"\n",(0,o.jsx)(n.p,{children:"Modules can implement interfaces that include the following components:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.a,{href:"/reference/syntax#defun",children:"function"})," signatures"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.a,{href:"/reference/syntax#defconst",children:"constant"})," values"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.a,{href:"/reference/syntax#defschema",children:"schema"})," definitions"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.a,{href:"/reference/syntax#defpact",children:"defpact"})," specifications"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.a,{href:"/reference/syntax#defcap",children:"capability"})," specifications"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.a,{href:"/reference/syntax#use",children:"imported definitions"})," from other modules"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"The following example illustrates how to declare and implement an interface with one function signature and one constant value:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-pact",children:'(interface my-interface\n    (defun hello-number:string (number:integer)\n      @doc "Return the string \\"Hello, $number!\\" when given a string"\n        )\n\n    (defconst SOME_CONSTANT 3)\n)\n\n(module my-module (read-keyset \'my-keyset)\n    (implements my-interface)\n\n    (defun hello-number:string (number:integer)\n        (format "Hello, {}!" [number]))\n\n    (defun square-three ()\n        (* my-interface.SOME_CONSTANT my-interface.SOME_CONSTANT))\n)\n'})}),"\n",(0,o.jsxs)(n.p,{children:["As you can see in this example, the ",(0,o.jsx)(n.code,{children:"my-module"})," module implements the ",(0,o.jsx)(n.code,{children:"hello-number"})," function signature.\nThe constant declared in the interface is accessed directly by its fully qualified name ",(0,o.jsx)(n.code,{children:"namespace.interface.const"}),"."]}),"\n",(0,o.jsx)(n.h2,{id:"implements-and-use-keywords",children:"Implements and use keywords"}),"\n",(0,o.jsxs)(n.p,{children:["You can create complex and layered relationships between interfaces and modules.\nOne important way you can create this layered relationships is by using combinations of the ",(0,o.jsx)(n.code,{children:"implements"})," and ",(0,o.jsx)(n.code,{children:"use"})," keywords.\nThe ",(0,o.jsx)(n.code,{children:"use"})," keyword enables you to import elements from the specified ",(0,o.jsx)(n.code,{children:"module"})," into a namespace, interface, or module.\nFor example, you can specify the ",(0,o.jsx)(n.code,{children:"use"})," keyword in an interface declaration to import table schemas and types from a specified module."]}),"\n",(0,o.jsxs)(n.p,{children:["You can also include ",(0,o.jsx)(n.code,{children:"use"})," statements at the top-level of a contract or within a module declaration to make all or parts of a specified module available in the current module context.\nFor example, you can specify a list of functions, constants, and schema names to import from the specified ",(0,o.jsx)(n.code,{children:"module"}),".\nIf you explicitly define the function, constant, and schema names to import, only those items are available in the module body."]}),"\n",(0,o.jsxs)(n.p,{children:["You can also specify a ",(0,o.jsx)(n.code,{children:"hash"})," argument in ",(0,o.jsx)(n.code,{children:"use"})," statements to check that an imported module's hash matches the ",(0,o.jsx)(n.code,{children:"hash"})," you expect, and fail if the hashes are not the same.\nBy including the ",(0,o.jsx)(n.code,{children:"hash"})," argument in a ",(0,o.jsx)(n.code,{children:"use"})," statement, you can perform a simplified form of version control or dependency checking."]}),"\n",(0,o.jsxs)(n.p,{children:["The following example is an excerpt from the ",(0,o.jsx)(n.code,{children:"marmalade-v2.ledger"})," module that illustrates the relationships created by combining ",(0,o.jsx)(n.code,{children:"implements"})," and ",(0,o.jsx)(n.code,{children:"use"})," statements.\nIn this example, ",(0,o.jsx)(n.code,{children:"marmalade-v2"})," is the primary namespace where the ",(0,o.jsx)(n.code,{children:"ledger"})," contract is deployed."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-pact",children:"(namespace (read-string 'ns))\n\n(module ledger GOVERNANCE\n\n  (implements marmalade-v2.ledger-v2)\n  (implements kip.poly-fungible-v3)\n\n  (use kip.poly-fungible-v3 [account-details sender-balance-change receiver-balance-change])\n  (use kip.token-policy-v2 [token-info])\n  (use util.fungible-util)\n  (use marmalade-v2.policy-manager)\n     ...\n)\n"})}),"\n",(0,o.jsxs)(n.p,{children:["This module implements the ",(0,o.jsx)(n.code,{children:"ledger-v2"})," interface that defines a set of capabilities."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-pact",children:'(interface ledger-v2\n\n  (defcap INIT-CALL:bool (id:string precision:integer uri:string)\n    @doc\n      "Capability securing the modref call for enforce-init "\n  )\n  ...\n\n)\n'})}),"\n",(0,o.jsxs)(n.p,{children:["The module also implements the ",(0,o.jsx)(n.code,{children:"poly-fungible-v3"})," interface and imports the specified functions."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-pact",children:'(interface poly-fungible-v3\n\n  (defschema account-details\n    @doc\n      " Account details: token ID, account name, balance, and guard."\n    id:string\n    account:string\n    balance:decimal\n    guard:guard)\n\n  (defschema sender-balance-change\n    @doc "For use in RECONCILE events"\n    account:string\n    previous:decimal\n    current:decimal\n  )\n\n  (defschema receiver-balance-change\n    @doc "For use in RECONCILE events"\n    account:string\n    previous:decimal\n    current:decimal\n  )\n...\n)\n'})}),"\n",(0,o.jsxs)(n.p,{children:["For more information about the syntax for using these keywords, see the ",(0,o.jsx)(n.a,{href:"/reference/syntax#implements",children:"implements"})," and ",(0,o.jsx)(n.a,{href:"/reference/syntax#use",children:"use"})," syntax descriptions."]}),"\n",(0,o.jsx)(n.h2,{id:"module-references",children:"Module references"}),"\n",(0,o.jsxs)(n.p,{children:["Pact ",(0,o.jsx)(n.strong,{children:"module references"})," enable you to support use-cases that require polymorphism.\nFor example, a Uniswap-like exchange allows users to specify pairs of tokens to allow trading between them.\nThe Pact ",(0,o.jsx)(n.code,{children:"fungible-v2"})," interface allows tokens to offer identical operations such as ",(0,o.jsx)(n.code,{children:"transfer-create"}),".\nHowever, without a way to abstract over different ",(0,o.jsx)(n.code,{children:"fungible-v2"})," implementations, an exchange smart contract would have to be upgraded for each token pair with custom code for every operation."]}),"\n",(0,o.jsx)(n.p,{children:"For example:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-pact",children:';;; simplified DEX example with hardcoded dispatching on token symbols\n(defun swap\n  ( a-token:string a-amount:decimal a-account:string\n    b-token:string b-amount:decimal b-account:string\n  )\n  (with-read pair-accounts (format "{}:{}" [a-token b-token])\n    { \'pair-a-account := pair-a-account\n    , \'pair-b-account := pair-b-account\n    }\n    (cond\n      ((= "KDA" a-token)\n       (coin.transfer a-account pair-a-account a-amount))\n      ((= "KBTC" a-token)\n       (kbtc.ledger.transfer a-account pair-a-account a-amount))\n      ((= "KUSD" a-token)\n       (kusd.ledger.transfer a-account pair-a-account a-amount))\n      "Unrecognized a-token value")\n    (cond\n      ((= "KDA" b-token)\n       (coin.transfer b-pair-account b-account b-amount))\n      ((= "KBTC" b-token)\n       (kbtc.ledger.transfer b-pair-account b-account b-amount))\n      ((= "KUSD" b-token)\n       (kusd.ledger.transfer b-pair-account b-account b-amount))\n      "Unrecognized b-token value"))\n)\n'})}),"\n",(0,o.jsxs)(n.p,{children:["With module references, an exchange-type smart contract can accept pairs of values where each value references a concrete module that implements the ",(0,o.jsx)(n.code,{children:"fungible-v2"})," interface, giving it the ability to call ",(0,o.jsx)(n.code,{children:"fungible-v2"})," operations using those values."]}),"\n",(0,o.jsx)(n.p,{children:"For example:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-pact",children:";;; simplified DEX example with module references in a dynamic dispatch\n(defun swap\n  ( a-token:module{fungible-v2} a-amount:decimal a-account:string\n    b-token:module{fungible-v2} b-amount:decimal b-account:string\n  )\n  (with-read pair-accounts (format \"{}:{}\" [a-token b-token])\n    { 'pair-a-account := pair-a-account\n    , 'pair-b-account := pair-b-account\n    }\n    (a-token::transfer a-account pair-a-account a-amount)\n    (b-token::transfer pair-b-account b-account b-amount))\n)\n"})}),"\n",(0,o.jsxs)(n.p,{children:["To invoke the ",(0,o.jsx)(n.code,{children:"swap"})," function, the module names are directly referenced in code."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-pact",children:"\n(swap coin a-amount a-account\n      kbtc.ledger b-amount b-account)\n\n"})}),"\n",(0,o.jsx)(n.p,{children:"Module reference values are normal Pact values that can be stored in the database, referenced in events, and returned from functions."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-pact",children:";;; simplified DEX example with stored pair module reference values\n(defun swap\n  ( pair-symbol:string\n    a-amount:decimal a-account:string\n    b-amount:decimal b-account:string\n  )\n  (with-read pair-accounts pair-symbol\n    { 'pair-a-account := pair-a-account:string\n    , 'a-token := a-token:module{fungible-v2}\n    , 'pair-b-account := pair-b-account:string\n    , 'b-token := b-token:module{fungible-v2}\n    }\n    (a-token::transfer a-account pair-a-account a-amount)\n    (b-token::transfer pair-b-account b-account b-amount))\n)\n"})}),"\n",(0,o.jsx)(n.h3,{id:"polymorphism",children:"Polymorphism"}),"\n",(0,o.jsx)(n.p,{children:"Module reference values provide polymorphism for use cases like the previous example with an emphasis on interoperability.\nA module reference is specified with one or more interfaces, allowing for values to reference modules that implement those interfaces."}),"\n",(0,o.jsxs)(n.p,{children:["In the previous example, the module reference ",(0,o.jsx)(n.code,{children:"a-token:module{fungible-v2}"})," accepts a reference to the Kadena ",(0,o.jsx)(n.code,{children:"coin"})," KDA token module, because ",(0,o.jsx)(n.code,{children:"coin"})," implements ",(0,o.jsx)(n.code,{children:"fungible-v2"}),".\nThere's nothing special about the ",(0,o.jsx)(n.code,{children:"fungible-v2"})," interface.\nModule references can specify any defined interface and accept any module that implements the specified interface."]}),"\n",(0,o.jsx)(n.p,{children:"The Pact module reference polymorphism is similar to generics in Java or traits in Rust, and should not be confused with more object-oriented polymorphism like that found with Java classes or TypeScript types.\nModules cannot extend one another.\nThey can only offer operations that match some interface specification, and interfaces themselves cannot extend other interface."}),"\n",(0,o.jsx)(n.p,{children:"You should note that module references introduce indirection and, therefore, can increase the overall complexity of Pact smart contracts, making contract logic harder to understand and reason about.\nYou should only use module references when you need to provide flexible interoperation between smart contracts.\nIf all of the modules are your own code, you should use direct references instead of external module references whenever possible."}),"\n",(0,o.jsx)(n.h3,{id:"reference-value-binding",children:"Reference value binding"}),"\n",(0,o.jsxs)(n.p,{children:["Module references use the latest upgraded version of the referenced module when you invoke a module operation.\nFor example, consider a module reference to a ",(0,o.jsx)(n.code,{children:"payments"})," module stored in the database when the ",(0,o.jsx)(n.code,{children:"payments"})," module is at version 1.\nSometime later, the ",(0,o.jsx)(n.code,{children:"payments"})," module is upgraded to version 2.\nThe module reference in the database will refer to the upgraded version 2 of the ",(0,o.jsx)(n.code,{children:"payments"})," module when the reference is called.\nThis behavior is different from Pact direct references, which are not late-binding, so you should consider this difference in module reference behavior to prevent returning unexpected results."]}),"\n",(0,o.jsx)(n.h3,{id:"referencing-untrusted-code",children:"Referencing untrusted code"}),"\n",(0,o.jsx)(n.p,{children:"Because module references allow external modules to interoperate with your code, you should not assume that the external code is safe.\nInstead, you should treat any module reference call as a call to untrusted code.\nIn particular, you should be aware that invoking module references in the context of acquiring a capability can result in unintended privilege escalation."}),"\n",(0,o.jsxs)(n.p,{children:["For example, the following ",(0,o.jsx)(n.code,{children:"data-market"})," module has a public ",(0,o.jsx)(n.code,{children:"collect-data"})," function that is intended to allow external modules to provide some data, resulting in the one-time payment of a fee.\nThe external modules implement a ",(0,o.jsx)(n.code,{children:"data-collector"})," interface with a ",(0,o.jsx)(n.code,{children:"collect"})," function to get the data and a ",(0,o.jsx)(n.code,{children:"get-fee-recipient"})," function to identify the receiving account.\nIn this example, the ",(0,o.jsx)(n.code,{children:"data-market"})," module code acquires the ",(0,o.jsx)(n.code,{children:"COLLECT"})," capability, and uses this capability to prevent ",(0,o.jsx)(n.code,{children:"collect"})," and a ",(0,o.jsx)(n.code,{children:"get-fee-recipient"})," functions from being called directly."]}),"\n",(0,o.jsx)(n.p,{children:"However, with the wrong code, this seemingly benign code can be exploited by a malicious module reference implementation:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-pact",children:'(module data-market GOVERNANCE\n  ...\n\n  (defun collect-data (collector:module{data-collector})\n    "Provide data, get paid!"\n    ;; BAD: capability acquired before modref calls\n    (with-capability (COLLECT)\n      ;; BAD: modref invoked with capability in scope!\n      (store-data (collector::collect))\n      (pay-fee (collector::get-fee-recipient)))\n  )\n\n  (defun pay-fee (account:string)\n    "Private function to pay one-time fee for collection"\n    (require-capability (COLLECT))\n    (coin.transfer FEE_BANK account FEE))\n\n  (defun store-data (data:object{data-schema})\n    "Private function to update database with data collection results"\n    (require-capability (COLLECT))\n    ...)\n)\n'})}),"\n",(0,o.jsxs)(n.p,{children:["The problem with the module code is that the ",(0,o.jsx)(n.code,{children:"with-capability"})," call happens ",(0,o.jsx)(n.em,{children:"before"})," the calls to the module reference operations, such that while the external module code is executing, the ",(0,o.jsx)(n.code,{children:"COLLECT"})," capability is in scope.\nWhile the ",(0,o.jsx)(n.code,{children:"COLLECT"})," capability is in scope, the ",(0,o.jsx)(n.code,{children:"pay-fee"})," and ",(0,o.jsx)(n.code,{children:"store-data"})," functions can be called from anywhere.\nMalicious code could exploit this code with a module reference that calls the ",(0,o.jsx)(n.code,{children:"data-market.pay-fee"})," function repeatedly in the seemingly innocent calls to the ",(0,o.jsx)(n.code,{children:"collect"})," or ",(0,o.jsx)(n.code,{children:"get-fee-recipient"})," functions.\nMalicious code could also call the ",(0,o.jsx)(n.code,{children:"data-market.store-data"})," function and wreak havoc that way.\nThe important point in this example is that once a capability is in scope, the protections provided by the ",(0,o.jsx)(n.code,{children:"require-capability"})," function aren't available."]}),"\n",(0,o.jsx)(n.p,{children:"Fortunately, you can avoid this situation by keeping module reference calls outside of the scope of the sensitive capability.\nFor example:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-pact",children:'(defun collect-data (collector:module{data-collector})\n  "Provide data, get paid!"\n  ;; GOOD: modref invoked before with-capability call\n  (let ((data (collector::collect))\n        (account (collector::get-fee-recipient)))\n    (with-capability (COLLECT)\n      (store-data data)\n      (pay-fee account))))\n'})}),"\n",(0,o.jsxs)(n.p,{children:["In this example, the module reference calls have safely returned before the ",(0,o.jsx)(n.code,{children:"COLLECT"})," capability is acquired.\nA malicious implementation has no way to invoke the sensitive code."]}),"\n",(0,o.jsx)(n.h3,{id:"coding-with-module-references",children:"Coding with module references"}),"\n",(0,o.jsx)(n.p,{children:"You can reference modules and interfaces directly by issuing their name in code.\nFor example:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-pact",children:"(module foo 'k\n  (defun bar () 0))\n\n(namespace ns)\n\n(interface bar\n  (defun quux:string ()))\n\n(module zzz 'k\n  (implements bar)\n  (defun quux:string () \"zzz\"))\n\nfoo ;; module reference to 'foo', of type 'module'\nns.bar ;; module reference to `bar` interface, also of type 'module'\nns.zzz ;; module reference to `zzz` module, of type 'module{ns.bar}'\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Using a module reference in a function is accomplished by specifying the type of the module reference argument, and using the ",(0,o.jsx)(n.a,{href:"/reference/syntax#dereference-operator",children:"dereference operator"})," ",(0,o.jsx)(n.code,{children:"::"})," to invoke a member function of the interface specified in the type."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-pact",children:"(interface baz\n  (defun quux:bool (a:integer b:string))\n  (defconst ONE 1)\n  )\n(module impl 'k\n  (implements baz)\n  (defun quux:bool (a:integer b:string)\n    (> (length b) a))\n  )\n\n...\n\n(defun foo (bar:module{baz})\n  (bar::quux 1 \"hi\")   ;; dereferences 'quux' on whatever module is passed in\n  bar::ONE             ;; directly references interface const\n)\n\n...\n\n(foo impl) ;; 'impl' references the module defined above, of type 'module{baz}'\n"})}),"\n",(0,o.jsx)(n.p,{children:"You should use module reference calls in use cases that require dynamic evaluation of a function or interface or when an interface requires multiple implementations.\nFor example, decentralized exchanges and liquidity pools typically require module references.\nYou should avoid using use module reference calls where you have a capability that you are using to guard resources could be brought into scope in an external module."}),"\n",(0,o.jsxs)(n.p,{children:["For example, if you are using the INTERNAL_FUNDS_CAP to guard account funds in the ",(0,o.jsx)(n.code,{children:"mymodule"})," module, you shouldn't bring that capability into scope before calling the external module:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-pact",children:"(module mymodule GOVERNANCE\n  ...\n  (defcap INTERNAL_FUNDS_CAP true) ; my capability for funds owned by this module\n  (defconst MODULE_ACCOUNT_GUARD (create-capability-guard (INTERNAL_FUNDS_CAP))\n  (defconst MODULE_ACCOUNT (create-principal MODULE_ACCOUNT_GUARD))\n  \n  (defun withdraw (person:string amount:decimal mref:module{fungible-v2}) \n    (with-capability (INTERNAL_FUNDS_CAP)\n      (mref::transfer person MODULE_ACCOUNT amount)\n      (coin.transfer MODULE_ACCOUNT person amount))))\n"})}),"\n",(0,o.jsxs)(n.p,{children:["In this example, the INTERNAL_FUNDS_CAP capability\u2014which should only be brought into scope for the ",(0,o.jsx)(n.code,{children:"coin.transfer"})," call\u2014is in scope for both the external ",(0,o.jsx)(n.code,{children:"mref::transfer"})," call and the ",(0,o.jsx)(n.code,{children:"coin.transfer"})," call.\nWith this vulnerability, a malicious user could write a module that satisfies the ",(0,o.jsx)(n.code,{children:"fungible-v2"})," interface that drains all of the funds from ",(0,o.jsx)(n.code,{children:"mymodule"})," because the INTERNAL_FUNDS_CAP is in scope."]}),"\n",(0,o.jsx)(n.p,{children:"To fix the issue, you need to change where the call that grants the INTERNAL_FUNDS_CAP capability is brought into scope:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-pact",children:"(defun withdraw (person:string amount:decimal mref:module{fungible-v2}) \n    (mref::transfer person MODULE_ACCOUNT amount)\n    (with-capability (INTERNAL_FUNDS_CAP)\n       (coin.transfer MODULE_ACCOUNT person amount))))\n"})}),"\n",(0,o.jsx)(n.h2,{id:"securing-module-reference-calls",children:"Securing module reference calls"}),"\n",(0,o.jsx)(n.p,{children:"Pact has always relied on restricting loops and preventing recursion to provide security guarantees.\nThese security measure ensure that your program can never enter into an infinite loop and functions can't call into themselves.\nHowever, module references introduced a potential vulnerability that Turing incompleteness alone didn't address.\nIn particular, virtual calls to module code that were not controlled by the module caller have been difficult for module authors to make secure.\nWhile functions are not allowed to recurse, module references don't prevent virtual calls from reentering the calling module.\nIf the virtual call then calls a separate credit or debit function, that call isn't considered recursion down the call stack.\nFor applications that rely on module references to provide the function interfaces they use, this behavior\u2014 combined with the importance of controlling capability scope\u2014has made it difficult for contract authors to write secure contract code."}),"\n",(0,o.jsxs)(n.p,{children:["As a security enhancement, Pact 5.3 introduces module reference calls that are ready-only by default.\nWith Pact 5.3, any module reference function call that reenters the originating module is treated as a read-only call to prevent database modification and code reentry attacks.\nFor example, assume you have a ",(0,o.jsx)(n.code,{children:"my-token"})," module with the module reference ",(0,o.jsx)(n.code,{children:"fungible::transfer-create"}),".\nIf the ",(0,o.jsx)(n.code,{children:"fungible"})," module tries to call back into the ",(0,o.jsx)(n.code,{children:"my-token"})," module to execute a ",(0,o.jsx)(n.code,{children:"withdraw-funds"})," or ",(0,o.jsx)(n.code,{children:"deposit-funds"})," function, the operation isn't allowed because all calls from the ",(0,o.jsx)(n.code,{children:"fungible"})," module reference  are read-only by default."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-pact",children:"(module my-token GOVERNANCE\n  ...\n  (defconst MODULE_GUARD (create-capability-guard (SOME-SECURE-CAP)))\n  (defconst MODULE_OWNED_ACCOUNT:string (create-principal ...))\n\n(defun withdraw-funds (account:string destination:module{fungible-v2})\n  (require-capability (SOME-SECURE-CAP))\n   # Code withdraws funds and transfers them to a particular account\n  )\n\n  (defun deposit-funds (account:string amount:decimal fung:module{fungible-v2})\n    (with-capability (SOME-SECURE-CAP)\n      (fungible::transfer-create account MODULE_OWNED_ACCOUNT MODULE_GUARD amount)))\n\n )\n"})}),"\n",(0,o.jsxs)(n.p,{children:["If the ",(0,o.jsx)(n.code,{children:"fungible::transfer-create"})," function were written to call back into ",(0,o.jsx)(n.code,{children:"my-token"}),", calls back into ",(0,o.jsx)(n.code,{children:"my-token"})," from the ",(0,o.jsx)(n.code,{children:"fungible"})," module reference would be allowed to ",(0,o.jsx)(n.strong,{children:"retrieve"})," information, such as account details, but not ",(0,o.jsx)(n.strong,{children:"modify"})," balances or any database entries that are part of the ",(0,o.jsx)(n.code,{children:"my-token"})," module."]}),"\n",(0,o.jsx)(n.p,{children:"For projects like decentralized exchanges (DEX) and bridges that require virtual calls, this enhancement enables Pact to provide module-level security guarantees against reentry attacks."})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>s});var a=t(96540);const o={},i=a.createContext(o);function r(e){const n=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),a.createElement(i.Provider,{value:n},e.children)}}}]);