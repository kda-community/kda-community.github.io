"use strict";(self.webpackChunkkadena_docs=self.webpackChunkkadena_docs||[]).push([[3770],{94303:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"smart-contracts/guards","title":"Guards","description":"Guards are an important concept in Kadena that provide a flexible way for you to enforce authorization rules that grant or restrict access based on specific conditions.","source":"@site/docs/smart-contracts/guards.md","sourceDirName":"smart-contracts","slug":"/smart-contracts/guards","permalink":"/docs/smart-contracts/guards","draft":false,"unlisted":false,"editUrl":"https://github.com/kda-community/kadena-docs-new/blob/master/docs/smart-contracts/guards.md","tags":[],"version":"current","sidebarPosition":9,"frontMatter":{"title":"Guards","description":"Guards are an important concept in Kadena that provide a flexible way for you to enforce authorization rules that grant or restrict access based on specific conditions.","id":"guards","sidebar_position":9},"sidebar":"default","previous":{"title":"Capabilities","permalink":"/docs/smart-contracts/capabilities"},"next":{"title":"Database model","permalink":"/docs/smart-contracts/databases"}}');var r=n(74848),s=n(28453);const i={title:"Guards",description:"Guards are an important concept in Kadena that provide a flexible way for you to enforce authorization rules that grant or restrict access based on specific conditions.",id:"guards",sidebar_position:9},o="Guards",c={},d=[{value:"Supported guards",id:"supported-guards",level:2},{value:"Guards and capabilities",id:"guards-and-capabilities",level:2},{value:"Keyset guards",id:"keyset-guards",level:2},{value:"Examples",id:"examples",level:3},{value:"Principal account prefix",id:"principal-account-prefix",level:3},{value:"KeysetRef guard",id:"keysetref-guard",level:2},{value:"Examples",id:"examples-1",level:3},{value:"User guard",id:"user-guard",level:2},{value:"Examples",id:"examples-2",level:3},{value:"Principal account prefix",id:"principal-account-prefix-1",level:3},{value:"Capability guard",id:"capability-guard",level:2},{value:"Principal account prefix",id:"principal-account-prefix-2",level:3}];function l(e){const a={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(a.header,{children:(0,r.jsx)(a.h1,{id:"guards",children:"Guards"})}),"\n",(0,r.jsxs)(a.p,{children:["In Pact, ",(0,r.jsx)(a.strong,{children:"guards"})," provide a flexible way for you to enforce authorization rules that grant or restrict access based on specific conditions.\nGuards generalize the behavior of keysets and capabilities to specify conditions that must be met before granting access to an account, a privileged operation, or any type of information that the guard is there to protect."]}),"\n",(0,r.jsxs)(a.p,{children:["Although Pact provides several types of guards to handle different scenarios and use cases, a guard is essentially a predicate function that enables you to test whether a condition is present (true) or not (false) with an ",(0,r.jsx)(a.code,{children:"enforce-guard"})," function."]}),"\n",(0,r.jsxs)(a.p,{children:["As you've already seen, a keyset is the most common type of guard.\nIt specifies a list of keys and a predicate function to verify how many keys were used to sign the current transaction.\nThe keyset predicate references a function that compares the public keys in the keyset to the key or keys used to sign the blockchain message.\nThe function accepts two arguments\u2014",(0,r.jsx)(a.code,{children:"count"})," and ",(0,r.jsx)(a.code,{children:"matched"}),"\u2014where ",(0,r.jsx)(a.code,{children:"count"})," is the number of keys in the keyset and ",(0,r.jsx)(a.code,{children:"matched"})," is how many keys in the message signature match a keyset key.\nThe ",(0,r.jsx)(a.code,{children:"enforce-keyset"})," function tests whether the required number of matching keys is true or false, determining whether the transaction succeeds with the required number of matched keys or fails because the required number of matched  weren't found in the signing set."]}),"\n",(0,r.jsx)(a.p,{children:"The following examples illustrate other use cases for guard predicate functions:"}),"\n",(0,r.jsxs)(a.ul,{children:["\n",(0,r.jsx)(a.li,{children:"Ensure that a user is a member of a privileged group that can execute a certain function."}),"\n",(0,r.jsx)(a.li,{children:"Verify that a user has provided some secret, such as the preimage data for a hash function, as is often done for atomic swaps."}),"\n",(0,r.jsx)(a.li,{children:"Enforce that a module is the only owner that can execute a specific function, for example, to debit a protected account."}),"\n"]}),"\n",(0,r.jsx)(a.p,{children:"Guards enable you combine all of these types of checks into a single, enforceable rule.\nFor example:"}),"\n",(0,r.jsxs)(a.p,{children:["Verify the user Alicia is a member of the Executive Board authorized to access the General Fund AND has provided the preimage data AND the transaction is only executable by the module ",(0,r.jsx)(a.code,{children:"general-fy2025"}),'".']}),"\n",(0,r.jsx)(a.h2,{id:"supported-guards",children:"Supported guards"}),"\n",(0,r.jsx)(a.p,{children:"Guards can have different properties based on what they are intended to protect access to, but can also interoperate with each other seamlessly.\nYou can include any or all of the following Pact guards in a smart contract:"}),"\n",(0,r.jsxs)(a.ul,{children:["\n",(0,r.jsx)(a.li,{children:"Keyset guard"}),"\n",(0,r.jsx)(a.li,{children:"KeysetRef guard"}),"\n",(0,r.jsx)(a.li,{children:"User guard"}),"\n",(0,r.jsx)(a.li,{children:"Capability guard"}),"\n",(0,r.jsx)(a.li,{children:"Module guard (DEPRECATED)"}),"\n",(0,r.jsx)(a.li,{children:"Pact guard (DEPRECATED)"}),"\n"]}),"\n",(0,r.jsx)(a.p,{children:"Note that the module guard and Pact guard are DEPRECATED because they are considered unsafe."}),"\n",(0,r.jsxs)(a.p,{children:["You can store guards in the Pact database using the ",(0,r.jsx)(a.code,{children:"guard"})," type.\nAlthough Pact defines these different guards to handle different use cases, the most important point to consider in selecting a guard is ensuring it enforces the appropriate conditions to allow or deny access to the appropriate entity, whether that entity is an account balance, a privileged operation, or a customizable user function."]}),"\n",(0,r.jsx)(a.h2,{id:"guards-and-capabilities",children:"Guards and capabilities"}),"\n",(0,r.jsx)(a.p,{children:"Guards and capabilities provide similar functionality in terms of authorizing access based on specific conditions.\nHowever, there are a few fundamental differences between guards and capabilities:"}),"\n",(0,r.jsxs)(a.ul,{children:["\n",(0,r.jsxs)(a.li,{children:["\n",(0,r.jsxs)(a.p,{children:["Guards allow you to define a ",(0,r.jsx)(a.em,{children:"rule"})," that must be satisfied for an operation or transaction to proceed.\nThey simply provide a way to declare a pass-fail condition\u2014the predicate function\u2014without granting any type of privilege or authorized activity.\nThe Pact guard system is flexible enough to express any rule you can code."]}),"\n"]}),"\n",(0,r.jsxs)(a.li,{children:["\n",(0,r.jsxs)(a.p,{children:["Capabilities allow you to declare how a rule is deployed to grant some ",(0,r.jsx)(a.em,{children:"authority"}),".\nIn doing so, they enumerate the critical rights that are extended to users of the smart contract, and protect code from being called incorrectly."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(a.p,{children:"In addition, you can only grant capabilities inside the module code that declares them.\nGuards are simply data that can be tested anywhere.\nFor capabilities, this is an important distinction because it ensures an attacker can't elevate privileges from outside of the module code."}),"\n",(0,r.jsx)(a.h2,{id:"keyset-guards",children:"Keyset guards"}),"\n",(0,r.jsxs)(a.p,{children:["The ",(0,r.jsx)(a.code,{children:"keyset"})," guard is the backward-compatible ",(0,r.jsx)(a.code,{children:"keyset"})," as originally defined in Pact.\nThis guard is also referred to as a ",(0,r.jsx)(a.strong,{children:"concrete keyset"})," that's defined in the environment.\nUsing the ",(0,r.jsx)(a.code,{children:"keyset"})," type is the one instance where you can restrict a guard subtype.\nFor all other guards, the ",(0,r.jsx)(a.code,{children:"guard"})," type obscures the implementation type to discourage you from using guard-specific control flow, which would be against best practices.\nIn general, you should use the ",(0,r.jsx)(a.code,{children:"guard"})," type unless you have a specific need to use a keyset."]}),"\n",(0,r.jsx)(a.h3,{id:"examples",children:"Examples"}),"\n",(0,r.jsxs)(a.p,{children:["To create a keyset guard with the name ",(0,r.jsx)(a.code,{children:"admin-keyset"}),":"]}),"\n",(0,r.jsx)(a.pre,{children:(0,r.jsx)(a.code,{className:"language-json",children:'{\n  "admin-keyset": {\n    "keys": [\n      "58705e8699678bd15bbda2cf40fa236694895db614aafc82cf1c06c014ca963c"\n    ],\n    "pred": "keys-all"\n  }\n}\n'})}),"\n",(0,r.jsx)(a.p,{children:"To define a keyset by reading a keyset object:"}),"\n",(0,r.jsx)(a.pre,{children:(0,r.jsx)(a.code,{className:"language-pact",children:'(define-keyset "admin-keyset" (read-keyset "admin-keyset"))\n(enforce-guard (read-keyset "admin-keyset"))\n'})}),"\n",(0,r.jsx)(a.h3,{id:"principal-account-prefix",children:"Principal account prefix"}),"\n",(0,r.jsxs)(a.p,{children:["Each type of principal and guard uses a unique prefix, so they are easy to recognize.\nIf you use the ",(0,r.jsx)(a.code,{children:"create-principal"})," function to a create principal account for a keyset guard, the principal account uses one of the following prefixes:"]}),"\n",(0,r.jsxs)(a.ul,{children:["\n",(0,r.jsx)(a.li,{children:"k: for single key keysets"}),"\n",(0,r.jsx)(a.li,{children:"w: for multiple keys keysets"}),"\n"]}),"\n",(0,r.jsx)(a.h2,{id:"keysetref-guard",children:"KeysetRef guard"}),"\n",(0,r.jsxs)(a.p,{children:["You can install concrete keyset guards in the REPL environment by using the ",(0,r.jsx)(a.code,{children:"define-keyset"})," function.\nHowever, if you want to store a reference to a defined keyset, you must use a ",(0,r.jsx)(a.code,{children:"string"})," type.\nTo make REPL environment keysets interoperate with concrete keysets and other guards, you can use the KeysetRef guard to indicate that a defined keyset is used instead of a concrete keyset."]}),"\n",(0,r.jsx)(a.h3,{id:"examples-1",children:"Examples"}),"\n",(0,r.jsx)(a.pre,{children:(0,r.jsx)(a.code,{className:"language-pact",children:'(enforce-guard (keyset-ref-guard "foo"))\n\n(update accounts user { "guard": (keyset-ref-guard "foo") })\n'})}),"\n",(0,r.jsx)(a.h2,{id:"user-guard",children:"User guard"}),"\n",(0,r.jsx)(a.p,{children:"User guards allow you to design an arbitrary predicate function to enforce the guard, given some initial data.\nWith user guards, you can implement any type custom predicate logic that can't be expressed by other built-in guard types."}),"\n",(0,r.jsx)(a.p,{children:"For example, you might want to customize the guard to allow one of two different keysets to sign:"}),"\n",(0,r.jsxs)(a.ul,{children:["\n",(0,r.jsx)(a.li,{children:"One keyset registers the keys for the members of a board of directors."}),"\n",(0,r.jsx)(a.li,{children:"A second keyset registers the keys for union representatives."}),"\n"]}),"\n",(0,r.jsx)(a.p,{children:"You can then design a user guard to require two separate keysets to be enforced:"}),"\n",(0,r.jsx)(a.pre,{children:(0,r.jsx)(a.code,{className:"language-pact",children:'(defun both-sign (board union)\n  (enforce-keyset board)\n  (enforce-keyset union))\n\n(defun install-both-guard ()\n  (write guard-table "both"\n    { "guard":\n      (create-user-guard\n        (both-sign (read-keyset "board) (read-keyset "union")))\n    }))\n\n\n(defun enforce-both-guard ()\n  (enforce-guard (at "guard" (read guard-table "both"))))\n'})}),"\n",(0,r.jsx)(a.p,{children:"User guards can be very flexible and powerful.\nThey can be stored in the database and passed around like plain data.\nHowever, user guards are pure functions that don't allow access to a database during evaluation of the guard."}),"\n",(0,r.jsx)(a.h3,{id:"examples-2",children:"Examples"}),"\n",(0,r.jsx)(a.p,{children:"The following example illustrates how to write a custom hash timelock guard to implement atomic swaps."}),"\n",(0,r.jsx)(a.pre,{children:(0,r.jsx)(a.code,{className:"language-pact",children:'\n(create-hashlock-guard (secret-hash timeout signer-ks)\n  (create-user-guard (enforce-hashlock secret-hash timeout signer-ks)))\n\n(defun enforce-hashlock (secret-hash timeout signer-ks)\n  (enforce-one [\n    (enforce (= (hash (read-msg "secret")) secret-hash))\n    (and\n      (enforce-keyset signer-ks)\n      (enforce (> (at "block-time" (chain-data)) timeout) "Timeout not passed"))\n      ]))\n'})}),"\n",(0,r.jsx)(a.h3,{id:"principal-account-prefix-1",children:"Principal account prefix"}),"\n",(0,r.jsxs)(a.p,{children:["Each type of principal and guard uses a unique prefix, so they are easy to recognize.\nIf you use the ",(0,r.jsx)(a.code,{children:"create-user-guard"})," function to create a principal account for a user guard, the principal account uses the following prefix:"]}),"\n",(0,r.jsxs)(a.ul,{children:["\n",(0,r.jsx)(a.li,{children:"u: for user guards"}),"\n"]}),"\n",(0,r.jsx)(a.h2,{id:"capability-guard",children:"Capability guard"}),"\n",(0,r.jsx)(a.p,{children:"Capabilities are in-module rights that can only be enforced within the declaring module, and offer scoping and the other benefits."}),"\n",(0,r.jsx)(a.p,{children:"Because user guards are required to be pure functions, they can't take database state into account.\nIf you need to access database state, you can define a guard that requires a capability to be brought into scope.\nWith this type of guard, you can retrieve database state when you bring the capability into scope."}),"\n",(0,r.jsx)(a.h3,{id:"principal-account-prefix-2",children:"Principal account prefix"}),"\n",(0,r.jsxs)(a.p,{children:["Each type of principal and guard uses a unique prefix, so they are easy to recognize.\nIf you use the ",(0,r.jsx)(a.code,{children:"create-capability-guard"})," function to create a principal account for a capability guard, the principal account uses the following prefix:"]}),"\n",(0,r.jsxs)(a.ul,{children:["\n",(0,r.jsx)(a.li,{children:"c: for capability guards"}),"\n"]})]})}function u(e={}){const{wrapper:a}={...(0,s.R)(),...e.components};return a?(0,r.jsx)(a,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},28453:(e,a,n)=>{n.d(a,{R:()=>i,x:()=>o});var t=n(96540);const r={},s=t.createContext(r);function i(e){const a=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(a):{...a,...e}}),[a,e])}function o(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),t.createElement(s.Provider,{value:a},e.children)}}}]);